def canPartition(self, nums):
        total = sum(nums)
        # If total sum is odd â†’ cannot split evenly
        if total % 2 != 0:
            return False

        target = total // 2

        # DP array: dp[s] = True/False
        dp = [False] * (target + 1)
        dp[0] = True  # sum=0 always possible

        for num in nums:
            # iterate backwards to avoid reuse
            for s in range(target, num - 1, -1):
                dp[s] = dp[s] or dp[s - num]

        return dp[target]


def coinChange(self, coins, amount):
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0

        for x in range(1, amount + 1):
            for c in coins:
                if x - c >= 0:
                    dp[x] = min(dp[x], dp[x - c] + 1)

        return dp[amount] if dp[amount] != float('inf') else -1


def maxSubArray(self, nums: List[int]) -> int:
        current_sum = max_sum = nums[0]

        for n in nums[1:]:
            current_sum = max(n, current_sum + n)
            max_sum = max(max_sum, current_sum)

        return max_sum